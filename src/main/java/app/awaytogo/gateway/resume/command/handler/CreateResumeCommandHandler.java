package app.awaytogo.gateway.resume.command.handler;

import app.awaytogo.gateway.resume.command.CreateResumeCommand;
import app.awaytogo.gateway.resume.domain.DomainEvent;
import app.awaytogo.gateway.resume.domain.ResumeAggregate;
import app.awaytogo.gateway.resume.domain.ResumeId;
import app.awaytogo.gateway.resume.domain.UserId;
import app.awaytogo.gateway.resume.infrastructure.messaging.DomainEventPublisher;
import app.awaytogo.gateway.resume.infrastructure.persistence.eventstore.EventStore;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.util.List;

@Component
public class CreateResumeCommandHandler {
    private static final Logger log = LoggerFactory.getLogger(CreateResumeCommandHandler.class);

    private final EventStore eventStore;
    private final DomainEventPublisher domainEventPublisher;

    public CreateResumeCommandHandler(EventStore eventStore, DomainEventPublisher domainEventPublisher) {
        this.eventStore = eventStore;
        this.domainEventPublisher = domainEventPublisher;
    }

    // @Transactional // Be cautious with @Transactional in reactive command handlers.
    // It might not behave as expected unless you have a ReactiveTransactionManager configured
    // and are using transactional operators like transactionalOperator.execute(status -> ...).
    // For event sourcing, the atomicity of saving a batch of events is key.
    public Mono<Void> handle(CreateResumeCommand command) { // Return Mono<Void> for reactive flow
        log.info("Handling CreateResumeCommand for resumeId: {}, userId: {}", command.resumeId(), command.userId());

        ResumeId resumeIdVo = new ResumeId(command.resumeId());
        UserId userIdVo = new UserId(command.userId());

        long expectedInitialVersion = -1L;

        ResumeAggregate resume = ResumeAggregate.create(resumeIdVo, userIdVo, command.linkedinUrl());
        log.debug("ResumeAggregate created for ID: {}", resumeIdVo.value());

        List<DomainEvent> newEvents = resume.getUncommittedEvents();
        if (newEvents.isEmpty()) {
            log.warn("No events generated by ResumeAggregate.create for resumeId: {}", resumeIdVo.value());
            return Mono.empty();
        }
        log.debug("Generated {} new events for resumeId: {}", newEvents.size(), resumeIdVo.value());

        // Assuming eventStore.saveEvents returns a Flux<T>
        return eventStore.saveEvents(resumeIdVo.value(), newEvents, expectedInitialVersion)
                .flatMap(v -> {
                    // 'v' is an item from the Flux returned by saveEvents
                    // This block is executed for each item 'v'.
                    // It publishes ALL newEvents and returns a Mono<Void> when done.
                    log.debug("Item from saveEvents received: {}. Publishing {} new events for resumeId: {}", v, newEvents.size(), resumeIdVo.value());
                    List<Mono<Void>> publishMonos = newEvents.stream()
                            .map(domainEventPublisher::publish)
                            .toList();
                    if (publishMonos.isEmpty()) {
                        return Mono.empty(); // Return Mono<Void> if no events to publish
                    }
                    return Flux.concat(publishMonos).then(); // This returns Mono<Void>
                }) // The result of Flux.flatMap(Function<T, Mono<Void>>) is Flux<Void>
                .then() // <--- ADD THIS LINE: Converts Flux<Void> to Mono<Void>
                .doOnSuccess(ignoredVoid -> { // Now this is called on Mono<Void>
                    resume.markEventsAsCommitted();
                    log.info("Successfully handled CreateResumeCommand and published events for resumeId: {}", resumeIdVo.value());
                })
                .doOnError(e -> log.error("Error handling CreateResumeCommand for resumeId: {}: {}", resumeIdVo.value(), e.getMessage(), e));
    }
}